================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-29T10:28:15.518Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.dockerignore
.gitattributes
.github/dependabot.yml
.github/workflows/ci.yml
.gitignore
.kamal/hooks/docker-setup.sample
.kamal/hooks/post-deploy.sample
.kamal/hooks/post-traefik-reboot.sample
.kamal/hooks/pre-build.sample
.kamal/hooks/pre-connect.sample
.kamal/hooks/pre-deploy.sample
.kamal/hooks/pre-traefik-reboot.sample
.rspec
.rubocop.yml
API_DOCUMENTATION.md
app/channels/application_cable/channel.rb
app/channels/application_cable/connection.rb
app/controllers/api/v1/payloads_controller.rb
app/controllers/application_controller.rb
app/controllers/concerns/error_handler.rb
app/controllers/concerns/rate_limitable.rb
app/controllers/payloads_controller.rb
app/jobs/application_job.rb
app/jobs/auto_delete_expired_payloads_job.rb
app/mailers/application_mailer.rb
app/models/application_record.rb
app/models/payload.rb
app/views/layouts/mailer.html.erb
app/views/layouts/mailer.text.erb
bin/brakeman
bin/bundle
bin/bundle.cmd
bin/docker-entrypoint
bin/rails
bin/rake
bin/rubocop
bin/setup
config.ru
config/application.rb
config/boot.rb
config/cable.yml
config/credentials.yml.enc
config/database.yml
config/environment.rb
config/environments/development.rb
config/environments/production.rb
config/environments/test.rb
config/initializers/filter_parameter_logging.rb
config/initializers/inflections.rb
config/initializers/scheduler.rb
config/initializers/tinyapi_config.rb
config/locales/en.yml
config/puma.rb
config/routes.rb
config/storage.yml
db/migrate/20240828072951_create_payloads.rb
db/migrate/YYYYMMDDHHMMSS_add_index_to_payloads.rb
db/migrate/YYYYMMDDHHMMSS_create_payloads.rb
db/schema.rb
db/seeds.rb
Dockerfile
Gemfile
Gemfile.lock
LICENSE.md
progress.md
public/robots.txt
Rakefile
README.md
spec/controllers/api/v1/payloads_controller_spec.rb
spec/factories/payloads.rb
spec/models/payload_spec.rb
spec/rails_helper.rb
spec/requests/api/v1/payloads_spec.rb
spec/spec_helper.rb
test/channels/application_cable/connection_test.rb
test/controllers/concerns/error_handler_test.rb
test/controllers/concerns/rate_limitable_test.rb
test/controllers/payloads_controller_test.rb
test/fixtures/payloads.yml
test/models/payload_test.rb
test/test_helper.rb

================================================================
Repository Files
================================================================

================
File: .dockerignore
================
# See https://docs.docker.com/engine/reference/builder/#dockerignore-file for more about ignoring files.

# Ignore git directory.
/.git/
/.gitignore

# Ignore bundler config.
/.bundle

# Ignore all environment files (except templates).
/.env*
!/.env*.erb

# Ignore all default key files.
/config/master.key
/config/credentials/*.key

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore pidfiles, but keep the directory.
/tmp/pids/*
!/tmp/pids/.keep

# Ignore storage (uploaded files in development and any SQLite databases).
/storage/*
!/storage/.keep
/tmp/storage/*
!/tmp/storage/.keep

# Ignore CI service files.
/.github

# Ignore development files
/.devcontainer

# Ignore Docker-related files
/.dockerignore
/Dockerfile*

================
File: .gitattributes
================
# See https://git-scm.com/docs/gitattributes for more about git attribute files.

# Mark the database schema as having been generated.
db/schema.rb linguist-generated

# Mark any vendored files as having been vendored.
vendor/* linguist-vendored
config/credentials/*.yml.enc diff=rails_credentials
config/credentials.yml.enc diff=rails_credentials

================
File: .github/dependabot.yml
================
version: 2
updates:
- package-ecosystem: bundler
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
- package-ecosystem: github-actions
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10

================
File: .github/workflows/ci.yml
================
name: CI

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  scan_ruby:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3.4'
          bundler-cache: true

      - name: Scan for common Rails security vulnerabilities using static analysis
        run: bundle exec brakeman --no-pager

  scan_js:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3.4'
          bundler-cache: true

      - name: Install dependencies
        run: |
          gem install bundler
          bundle install

      - name: List installed gems
        run: bundle list

      - name: Check for outdated gems
        run: bundle outdated

  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3.4'
          bundler-cache: true

      - name: Lint code for consistent style
        run: bundle exec rubocop -f github

  test:
    runs-on: ubuntu-latest

    services:
      redis:
        image: redis
        ports:
          - 6379:6379
        options: --health-cmd "redis-cli ping" --health-interval 10s --health-timeout 5s --health-retries 5

    steps:
      - name: Install packages
        run: sudo apt-get update && sudo apt-get install --no-install-recommends -y google-chrome-stable curl libjemalloc2 libvips sqlite3

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3.4'
          bundler-cache: true

      - name: Run tests
        env:
          RAILS_ENV: test
          REDIS_URL: redis://localhost:6379/0
        run: |
          bundle exec rails db:test:prepare
          bundle exec rails test

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: true
          verbose: true

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# Temporary files generated by your text editor or operating system
# belong in git's global ignore instead:
# `$XDG_CONFIG_HOME/git/ignore` or `~/.config/git/ignore`

# Ignore bundler config.
/.bundle

# Ignore all environment files (except templates).
/.env*
!/.env*.erb

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore pidfiles, but keep the directory.
/tmp/pids/*
!/tmp/pids/
!/tmp/pids/.keep

# Ignore uploaded files in development.
/storage/*
!/storage/.keep
/tmp/storage/*
!/tmp/storage/
!/tmp/storage/.keep

# Ignore master key for decrypting credentials and more.
/config/master.key

# Ignore database files
/db/*.sqlite3
/db/*.sqlite3-*

# Ignore all .env files
.env*

# Ignore system files
.DS_Store
Thumbs.db

# Ignore node modules
/node_modules

# Ignore yarn files
/yarn-error.log
yarn-debug.log*
.yarn-integrity

# Ignore coverage reports
/coverage

# Ignore Redis dump file
dump.rdb

# Ignore RSpec state
spec/examples.txt

# Ignore public uploads
/public/uploads

# Ignore IDE-specific files
.idea/
.vscode/
*.swp
*.swo

# Ignore Ruby version file
.ruby-version

# Ignore `
.cursorrules
files_to_remove.txt

================
File: .kamal/hooks/docker-setup.sample
================
#!/usr/bin/env ruby

# A sample docker-setup hook
#
# Sets up a Docker network on defined hosts which can then be used by the applicationâ€™s containers

hosts = ENV["KAMAL_HOSTS"].split(",")

hosts.each do |ip|
  destination = "root@#{ip}"
  puts "Creating a Docker network \"kamal\" on #{destination}"
  `ssh #{destination} docker network create kamal`
end

================
File: .kamal/hooks/post-deploy.sample
================
#!/bin/sh

# A sample post-deploy hook
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLE (if set)
# KAMAL_DESTINATION (if set)
# KAMAL_RUNTIME

echo "$KAMAL_PERFORMER deployed $KAMAL_VERSION to $KAMAL_DESTINATION in $KAMAL_RUNTIME seconds"

================
File: .kamal/hooks/post-traefik-reboot.sample
================
#!/bin/sh

echo "Rebooted Traefik on $KAMAL_HOSTS"

================
File: .kamal/hooks/pre-build.sample
================
#!/bin/sh

# A sample pre-build hook
#
# Checks:
# 1. We have a clean checkout
# 2. A remote is configured
# 3. The branch has been pushed to the remote
# 4. The version we are deploying matches the remote
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLE (if set)
# KAMAL_DESTINATION (if set)

if [ -n "$(git status --porcelain)" ]; then
  echo "Git checkout is not clean, aborting..." >&2
  git status --porcelain >&2
  exit 1
fi

first_remote=$(git remote)

if [ -z "$first_remote" ]; then
  echo "No git remote set, aborting..." >&2
  exit 1
fi

current_branch=$(git branch --show-current)

if [ -z "$current_branch" ]; then
  echo "Not on a git branch, aborting..." >&2
  exit 1
fi

remote_head=$(git ls-remote $first_remote --tags $current_branch | cut -f1)

if [ -z "$remote_head" ]; then
  echo "Branch not pushed to remote, aborting..." >&2
  exit 1
fi

if [ "$KAMAL_VERSION" != "$remote_head" ]; then
  echo "Version ($KAMAL_VERSION) does not match remote HEAD ($remote_head), aborting..." >&2
  exit 1
fi

exit 0

================
File: .kamal/hooks/pre-connect.sample
================
#!/usr/bin/env ruby

# A sample pre-connect check
#
# Warms DNS before connecting to hosts in parallel
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_ROLE (if set)
# KAMAL_DESTINATION (if set)
# KAMAL_RUNTIME

hosts = ENV["KAMAL_HOSTS"].split(",")
results = nil
max = 3

elapsed = Benchmark.realtime do
  results = hosts.map do |host|
    Thread.new do
      tries = 1

      begin
        Socket.getaddrinfo(host, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
      rescue SocketError
        if tries < max
          puts "Retrying DNS warmup: #{host}"
          tries += 1
          sleep rand
          retry
        else
          puts "DNS warmup failed: #{host}"
          host
        end
      end

      tries
    end
  end.map(&:value)
end

retries = results.sum - hosts.size
nopes = results.count { |r| r == max }

puts "Prewarmed %d DNS lookups in %.2f sec: %d retries, %d failures" % [ hosts.size, elapsed, retries, nopes ]

================
File: .kamal/hooks/pre-deploy.sample
================
#!/usr/bin/env ruby

# A sample pre-deploy hook
#
# Checks the Github status of the build, waiting for a pending build to complete for up to 720 seconds.
#
# Fails unless the combined status is "success"
#
# These environment variables are available:
# KAMAL_RECORDED_AT
# KAMAL_PERFORMER
# KAMAL_VERSION
# KAMAL_HOSTS
# KAMAL_COMMAND
# KAMAL_SUBCOMMAND
# KAMAL_ROLE (if set)
# KAMAL_DESTINATION (if set)

# Only check the build status for production deployments
if ENV["KAMAL_COMMAND"] == "rollback" || ENV["KAMAL_DESTINATION"] != "production"
  exit 0
end

require "bundler/inline"

# true = install gems so this is fast on repeat invocations
gemfile(true, quiet: true) do
  source "https://rubygems.org"

  gem "octokit"
  gem "faraday-retry"
end

MAX_ATTEMPTS = 72
ATTEMPTS_GAP = 10

def exit_with_error(message)
  $stderr.puts message
  exit 1
end

class GithubStatusChecks
  attr_reader :remote_url, :git_sha, :github_client, :combined_status

  def initialize
    @remote_url = `git config --get remote.origin.url`.strip.delete_prefix("https://github.com/")
    @git_sha = `git rev-parse HEAD`.strip
    @github_client = Octokit::Client.new(access_token: ENV["GITHUB_TOKEN"])
    refresh!
  end

  def refresh!
    @combined_status = github_client.combined_status(remote_url, git_sha)
  end

  def state
    combined_status[:state]
  end

  def first_status_url
    first_status = combined_status[:statuses].find { |status| status[:state] == state }
    first_status && first_status[:target_url]
  end

  def complete_count
    combined_status[:statuses].count { |status| status[:state] != "pending"}
  end

  def total_count
    combined_status[:statuses].count
  end

  def current_status
    if total_count > 0
      "Completed #{complete_count}/#{total_count} checks, see #{first_status_url} ..."
    else
      "Build not started..."
    end
  end
end


$stdout.sync = true

puts "Checking build status..."
attempts = 0
checks = GithubStatusChecks.new

begin
  loop do
    case checks.state
    when "success"
      puts "Checks passed, see #{checks.first_status_url}"
      exit 0
    when "failure"
      exit_with_error "Checks failed, see #{checks.first_status_url}"
    when "pending"
      attempts += 1
    end

    exit_with_error "Checks are still pending, gave up after #{MAX_ATTEMPTS * ATTEMPTS_GAP} seconds" if attempts == MAX_ATTEMPTS

    puts checks.current_status
    sleep(ATTEMPTS_GAP)
    checks.refresh!
  end
rescue Octokit::NotFound
  exit_with_error "Build status could not be found"
end

================
File: .kamal/hooks/pre-traefik-reboot.sample
================
#!/bin/sh

echo "Rebooting Traefik on $KAMAL_HOSTS..."

================
File: .rspec
================
--require spec_helper

================
File: .rubocop.yml
================
# Omakase Ruby styling for Rails
inherit_gem: { rubocop-rails-omakase: rubocop.yml }

# Overwrite or add rules to create your own house style
#
# # Use `[a, [b, c]]` not `[ a, [ b, c ] ]`
# Layout/SpaceInsideArrayLiteralBrackets:
#   Enabled: false

AllCops:
  NewCops: enable
  TargetRubyVersion: 3.0

Style/Documentation:
  Enabled: false

Style/FrozenStringLiteralComment:
  Enabled: false

Metrics/MethodLength:
  Max: 20

Metrics/AbcSize:
  Max: 30

Layout/LineLength:
  Max: 120

Style/StringLiterals:
  EnforcedStyle: double_quotes

================
File: API_DOCUMENTATION.md
================
# TinyAPI Documentation

TinyAPI is a simple storage service that allows users to save and edit payloads through a RESTful API. For now, it is still WIP and would support authentication based rate limits in future. 

## API Versioning

The API is versioned using URL namespacing. The current version is v1.

Base URL: `/api/v1`

## Authentication

All requests must include a client token in the header for client identification.
Header: `X-Client-Token: <token>`

Note: In v1, this token is a placeholder with no validation.

## Endpoints

### 1. Add Payload

**POST /api/v1/payloads**

Add a new payload to the system.

#### Request Body

================
File: app/channels/application_cable/channel.rb
================
module ApplicationCable
  class Channel < ActionCable::Channel::Base
  end
end

================
File: app/channels/application_cable/connection.rb
================
module ApplicationCable
  class Connection < ActionCable::Connection::Base
  end
end

================
File: app/controllers/api/v1/payloads_controller.rb
================
module Api
  module V1
    class PayloadsController < ApplicationController
      include RateLimitable

      def create
        payload = Payload.new(payload_params)
        payload.hash_id = SecureRandom.hex(10)

        if payload.save
          render json: payload_response(payload), status: :created
        else
          render json: { errors: payload.errors.full_messages }, status: :unprocessable_entity
        end
      end

      def update
        payload = Payload.find_by!(hash_id: params[:hash_id])

        if payload.update(payload_params)
          render json: payload_response(payload)
        else
          render json: { errors: payload.errors.full_messages }, status: :unprocessable_entity
        end
      rescue ActiveRecord::RecordNotFound
        render json: { error: "Payload not found" }, status: :not_found
      end

      def show
        payload = Payload.find_by!(hash_id: params[:hash_id])
        payload.update(viewed_at: Time.current)

        render json: payload_response(payload)
      rescue ActiveRecord::RecordNotFound
        render json: { error: "Payload not found" }, status: :not_found
      end

      private

      def payload_params
        params.require(:payload).permit(:content, :mime_type, :expiry_time)
      end

      def payload_response(payload)
        {
          hash_id: payload.hash_id,
          content: payload.content,
          mime_type: payload.mime_type,
          created_at: payload.created_at,
          updated_at: payload.updated_at,
          viewed_at: payload.viewed_at,
          expiry_time: payload.expiry_time
        }
      end
    end
  end
end

================
File: app/controllers/application_controller.rb
================
class ApplicationController < ActionController::API
end

================
File: app/controllers/concerns/error_handler.rb
================
module ErrorHandler
  extend ActiveSupport::Concern

  included do
    rescue_from ActiveRecord::RecordNotFound, with: :handle_not_found
    rescue_from ActiveRecord::RecordInvalid, with: :handle_invalid_record
    rescue_from ActiveRecord::RecordNotUnique, with: :handle_not_unique
  end

  private

  def handle_not_found(exception)
    render json: { error: "Resource not found" }, status: :not_found
  end

  def handle_invalid_record(exception)
    render json: { error: exception.record.errors.full_messages }, status: :unprocessable_entity
  end

  def handle_not_unique(exception)
    render json: { error: "Resource already exists" }, status: :conflict
  end
end

================
File: app/controllers/concerns/rate_limitable.rb
================
module RateLimitable
  extend ActiveSupport::Concern

  included do
    before_action :check_rate_limit
  end

  private

  def check_rate_limit
    limit = Rails.configuration.tinyapi.rate_limits[action_name.to_sym] || 1000 # Default to 1000 if not set
    key = "rate_limit:#{request.headers["X-Client-Token"]}:#{controller_name}:#{action_name}"
    count = Rails.cache.increment(key, 1, expires_in: 1.hour)

    if count > limit
      render json: { error: "Rate limit exceeded" }, status: :too_many_requests
    end
  rescue Redis::CannotConnectError => e
    Rails.logger.error "Redis connection error: #{e.message}"
    # Allow the request to proceed if Redis is unavailable
  end
end

================
File: app/controllers/payloads_controller.rb
================
class PayloadsController < ApplicationController
  before_action :set_payload, only: [ :show, :update ]

  def index
    @payloads = Payload.all
    render json: @payloads
  end

  def show
    render json: @payload
  end

  def create
    @payload = Payload.new(payload_params)
    @payload.hash_id = SecureRandom.hex(10) # Generate a unique hash_id

    if @payload.save
      render json: @payload, status: :created, location: @payload
    else
      render json: @payload.errors, status: :unprocessable_entity
    end
  end

  def update
    if @payload.update(payload_params)
      render json: @payload
    else
      render json: @payload.errors, status: :unprocessable_entity
    end
  end

  private

  def set_payload
    @payload = Payload.find_by!(hash_id: params[:id])
  rescue ActiveRecord::RecordNotFound
    render json: { error: "Payload not found" }, status: :not_found
  end

  def payload_params
    params.require(:payload).permit(:content, :mime_type)
  end
end

================
File: app/jobs/application_job.rb
================
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end

================
File: app/jobs/auto_delete_expired_payloads_job.rb
================
class AutoDeleteExpiredPayloadsJob < ApplicationJob
  queue_as :default

  def perform
    Payload.where("expiry_time <= ?", Time.current).delete_all
    Payload.where("viewed_at <= ?", 6.days.ago).delete_all
  end
end

================
File: app/mailers/application_mailer.rb
================
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end

================
File: app/models/application_record.rb
================
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end

================
File: app/models/payload.rb
================
class Payload < ApplicationRecord
  MAX_CONTENT_SIZE = 10.megabytes
  MAX_EXPIRY_TIME = 30.days

  attr_accessor :skip_callbacks

  validates :content, presence: true, length: { maximum: MAX_CONTENT_SIZE }
  validates :mime_type, presence: true
  validates :hash_id, presence: true, uniqueness: true
  validate :content_size_within_limit
  validate :expiry_time_within_limit

  before_validation :set_default_values, unless: :skip_callbacks

  private

  def set_default_values
    set_default_mime_type
    set_hash_id
    set_expiry_time
  end

  def set_default_mime_type
    self.mime_type ||= "text/plain"
  end

  def set_hash_id
    self.hash_id ||= SecureRandom.hex(10)
  end

  def set_expiry_time
    self.expiry_time ||= MAX_EXPIRY_TIME.from_now
  end

  def content_size_within_limit
    return if content.blank?

    if content.bytesize > MAX_CONTENT_SIZE
      errors.add(:content, "size exceeds the limit of #{MAX_CONTENT_SIZE} bytes")
    end
  end

  def expiry_time_within_limit
    return if expiry_time.blank?

    if expiry_time > MAX_EXPIRY_TIME.from_now
      self.expiry_time = MAX_EXPIRY_TIME.from_now
    end
  end
end

================
File: app/views/layouts/mailer.html.erb
================
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>

================
File: app/views/layouts/mailer.text.erb
================
<%= yield %>

================
File: bin/brakeman
================
#!/usr/bin/env ruby.exe
require "rubygems"
require "bundler/setup"

ARGV.unshift("--ensure-latest")

load Gem.bin_path("brakeman", "brakeman")

================
File: bin/bundle
================
#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler.
#
# The application 'bundle' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require "rubygems"

m = Module.new do
  module_function

  def invoked_as_script?
    File.expand_path($0) == File.expand_path(__FILE__)
  end

  def env_var_version
    ENV["BUNDLER_VERSION"]
  end

  def cli_arg_version
    return unless invoked_as_script? # don't want to hijack other binstubs
    return unless "update".start_with?(ARGV.first || " ") # must be running `bundle update`
    bundler_version = nil
    update_index = nil
    ARGV.each_with_index do |a, i|
      if update_index && update_index.succ == i && a.match?(Gem::Version::ANCHORED_VERSION_PATTERN)
        bundler_version = a
      end
      next unless a =~ /\A--bundler(?:[= ](#{Gem::Version::VERSION_PATTERN}))?\z/
      bundler_version = $1
      update_index = i
    end
    bundler_version
  end

  def gemfile
    gemfile = ENV["BUNDLE_GEMFILE"]
    return gemfile if gemfile && !gemfile.empty?

    File.expand_path("../Gemfile", __dir__)
  end

  def lockfile
    lockfile =
      case File.basename(gemfile)
      when "gems.rb" then gemfile.sub(/\.rb$/, ".locked")
      else "#{gemfile}.lock"
      end
    File.expand_path(lockfile)
  end

  def lockfile_version
    return unless File.file?(lockfile)
    lockfile_contents = File.read(lockfile)
    return unless lockfile_contents =~ /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/
    Regexp.last_match(1)
  end

  def bundler_requirement
    @bundler_requirement ||=
      env_var_version ||
      cli_arg_version ||
      bundler_requirement_for(lockfile_version)
  end

  def bundler_requirement_for(version)
    return "#{Gem::Requirement.default}.a" unless version

    bundler_gem_version = Gem::Version.new(version)

    bundler_gem_version.approximate_recommendation
  end

  def load_bundler!
    ENV["BUNDLE_GEMFILE"] ||= gemfile

    activate_bundler
  end

  def activate_bundler
    gem_error = activation_error_handling do
      gem "bundler", bundler_requirement
    end
    return if gem_error.nil?
    require_error = activation_error_handling do
      require "bundler/version"
    end
    return if require_error.nil? && Gem::Requirement.new(bundler_requirement).satisfied_by?(Gem::Version.new(Bundler::VERSION))
    warn "Activating bundler (#{bundler_requirement}) failed:\n#{gem_error.message}\n\nTo install the version of bundler this project requires, run `gem install bundler -v '#{bundler_requirement}'`"
    exit 42
  end

  def activation_error_handling
    yield
    nil
  rescue StandardError, LoadError => e
    e
  end
end

m.load_bundler!

if m.invoked_as_script?
  load Gem.bin_path("bundler", "bundle")
end

================
File: bin/bundle.cmd
================
@ruby -x "%~f0" %*
@exit /b %ERRORLEVEL%

#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler.
#
# The application 'bundle' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require "rubygems"

m = Module.new do
  module_function

  def invoked_as_script?
    File.expand_path($0) == File.expand_path(__FILE__)
  end

  def env_var_version
    ENV["BUNDLER_VERSION"]
  end

  def cli_arg_version
    return unless invoked_as_script? # don't want to hijack other binstubs
    return unless "update".start_with?(ARGV.first || " ") # must be running `bundle update`
    bundler_version = nil
    update_index = nil
    ARGV.each_with_index do |a, i|
      if update_index && update_index.succ == i && a.match?(Gem::Version::ANCHORED_VERSION_PATTERN)
        bundler_version = a
      end
      next unless a =~ /\A--bundler(?:[= ](#{Gem::Version::VERSION_PATTERN}))?\z/
      bundler_version = $1
      update_index = i
    end
    bundler_version
  end

  def gemfile
    gemfile = ENV["BUNDLE_GEMFILE"]
    return gemfile if gemfile && !gemfile.empty?

    File.expand_path("../Gemfile", __dir__)
  end

  def lockfile
    lockfile =
      case File.basename(gemfile)
      when "gems.rb" then gemfile.sub(/\.rb$/, ".locked")
      else "#{gemfile}.lock"
      end
    File.expand_path(lockfile)
  end

  def lockfile_version
    return unless File.file?(lockfile)
    lockfile_contents = File.read(lockfile)
    return unless lockfile_contents =~ /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/
    Regexp.last_match(1)
  end

  def bundler_requirement
    @bundler_requirement ||=
      env_var_version ||
      cli_arg_version ||
      bundler_requirement_for(lockfile_version)
  end

  def bundler_requirement_for(version)
    return "#{Gem::Requirement.default}.a" unless version

    bundler_gem_version = Gem::Version.new(version)

    bundler_gem_version.approximate_recommendation
  end

  def load_bundler!
    ENV["BUNDLE_GEMFILE"] ||= gemfile

    activate_bundler
  end

  def activate_bundler
    gem_error = activation_error_handling do
      gem "bundler", bundler_requirement
    end
    return if gem_error.nil?
    require_error = activation_error_handling do
      require "bundler/version"
    end
    return if require_error.nil? && Gem::Requirement.new(bundler_requirement).satisfied_by?(Gem::Version.new(Bundler::VERSION))
    warn "Activating bundler (#{bundler_requirement}) failed:\n#{gem_error.message}\n\nTo install the version of bundler this project requires, run `gem install bundler -v '#{bundler_requirement}'`"
    exit 42
  end

  def activation_error_handling
    yield
    nil
  rescue StandardError, LoadError => e
    e
  end
end

m.load_bundler!

if m.invoked_as_script?
  load Gem.bin_path("bundler", "bundle")
end

================
File: bin/docker-entrypoint
================
#!/bin/bash -e

# Enable jemalloc for reduced memory usage and latency.
if [ -z "${LD_PRELOAD+x}" ] && [ -f /usr/lib/*/libjemalloc.so.2 ]; then
  export LD_PRELOAD="$(echo /usr/lib/*/libjemalloc.so.2)"
fi

# If running the rails server then create or migrate existing database
if [ "${1}" == "./bin/rails" ] && [ "${2}" == "server" ]; then
  ./bin/rails db:prepare
fi

exec "${@}"

================
File: bin/rails
================
#!/usr/bin/env ruby.exe
APP_PATH = File.expand_path("../config/application", __dir__)
require_relative "../config/boot"
require "rails/commands"

================
File: bin/rake
================
#!/usr/bin/env ruby.exe
require_relative "../config/boot"
require "rake"
Rake.application.run

================
File: bin/rubocop
================
#!/usr/bin/env ruby.exe
require "rubygems"
require "bundler/setup"

# explicit rubocop config increases performance slightly while avoiding config confusion.
ARGV.unshift("--config", File.expand_path("../.rubocop.yml", __dir__))

load Gem.bin_path("rubocop", "rubocop")

================
File: bin/setup
================
#!/usr/bin/env ruby.exe
require "fileutils"

APP_ROOT = File.expand_path("..", __dir__)
APP_NAME = "tiny-api"

def system!(*args)
  system(*args, exception: true)
end

FileUtils.chdir APP_ROOT do
  # This script is a way to set up or update your development environment automatically.
  # This script is idempotent, so that you can run it at any time and get an expectable outcome.
  # Add necessary setup steps to this file.

  puts "== Installing dependencies =="
  system! "gem install bundler --conservative"
  system("bundle check") || system!("bundle install")

  # puts "\n== Copying sample files =="
  # unless File.exist?("config/database.yml")
  #   FileUtils.cp "config/database.yml.sample", "config/database.yml"
  # end

  puts "\n== Preparing database =="
  system! "bin/rails db:prepare"

  puts "\n== Removing old logs and tempfiles =="
  system! "bin/rails log:clear tmp:clear"

  puts "\n== Restarting application server =="
  system! "bin/rails restart"

  # puts "\n== Configuring puma-dev =="
  # system "ln -nfs #{APP_ROOT} ~/.puma-dev/#{APP_NAME}"
  # system "curl -Is https://#{APP_NAME}.test/up | head -n 1"
end

================
File: config.ru
================
# This file is used by Rack-based servers to start the application.

require_relative "config/environment"

run Rails.application
Rails.application.load_server

================
File: config/application.rb
================
require_relative "boot"

require "rails/all"

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

module TinyApi
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 7.2

    # Please, add to the `ignore` list any other `lib` subdirectories that do
    # not contain `.rb` files, or that should not be reloaded or eager loaded.
    # Common ones are `templates`, `generators`, or `middleware`, for example.
    config.autoload_lib(ignore: %w[ssets task])

    # Configuration for the application, engines, and railties goes here.
    #
    # These settings can be overridden in specific environments using the files
    # in config/environments, which are processed later.
    #
    # config.time_zone = "Central Time (US & Canada)"
    # config.eager_load_paths << Rails.root.join("extras")

    # Only loads a smaller set of middleware suitable for API only apps.
    # Middleware like session, flash, cookies can be added back manually.
    # Skip views, helpers and assets when generating a new resource.
    config.api_only = true
  end
end

================
File: config/boot.rb
================
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "bundler/setup" # Set up gems listed in the Gemfile.
require "bootsnap/setup" # Speed up boot time by caching expensive operations.

================
File: config/cable.yml
================
development:
  adapter: async

test:
  adapter: test

production:
  adapter: redis
  url: <%= ENV.fetch("REDIS_URL") { "redis://localhost:6379/1" } %>
  channel_prefix: tiny_api_production

================
File: config/credentials.yml.enc
================
/I/7IAyBLRUD2LOxlnmAKJqGSlPBUzoB5FJ0rqQGNZlLNaOetsbejT593gNqzMk7rODohjyRjZh5fJI83o/p2LUCp1JlwL9rk/CHRgE34rX1DxwxLdgy2tAgVy3BgCWXUNQ6y0AIKR917OTscCOE/vNio0VJOt269DMiKVbJRTX409cE0ixbYor+r5V5FMfKJLULxF9NdN5UinVpK04VXOjt6gEuqJK97bIJiWRvRSppHkTeNxuHTa+mRUflWRU16Nz7lLVGoDAiRUy7xnXicUr+5cAc9xNhdTShrO7c5gFwrD5qbUncMdOg46kAfFx8ONwlJ2Hg0fJUHYAB+xvXUznkZz4ZUIBwp18uwMGo1hmPv71rBQROOEqtG9o6cOZf5R4B8xVjo+7D+io6+ii+8vuODGfY--+bp6+VOyHLGW7Cua--akuh3ZjsIUy/GOb/QEYNpQ==

================
File: config/database.yml
================
# SQLite. Versions 3.8.0 and up are supported.
#   gem install sqlite3
#
#   Ensure the SQLite 3 gem is defined in your Gemfile
#   gem "sqlite3"
#
default: &default
  adapter: sqlite3
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  timeout: 5000

development:
  <<: *default
  database: db/development.sqlite3

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  <<: *default
  database: db/test.sqlite3

# SQLite3 write its data on the local filesystem, as such it requires
# persistent disks. If you are deploying to a managed service, you should
# make sure it provides disk persistence, as many don't.
#
# Similarly, if you deploy your application as a Docker container, you must
# ensure the database is located in a persisted volume.
production:
  <<: *default
  database: db/production.sqlite3

================
File: config/environment.rb
================
# Load the Rails application.
require_relative "application"

# Initialize the Rails application.
Rails.application.initialize!

================
File: config/environments/development.rb
================
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # In the development environment your application"s code is reloaded any time
  # it changes. This slows down response time but is perfect for development
  # since you don"t have to restart the web server when you make code changes.
  config.enable_reloading = true

  # Do not eager load code on boot.
  config.eager_load = false

  # Show full error reports.
  config.consider_all_requests_local = true

  # Enable server timing.
  config.server_timing = true

  # Enable/disable caching. By default caching is disabled.
  # Run rails dev:cache to toggle caching.
  if Rails.root.join("tmp/caching-dev.txt").exist?
    config.cache_store = :memory_store
    config.public_file_server.headers = { "Cache-Control" => "public, max-age=#{2.days.to_i}" }
  else
    config.action_controller.perform_caching = false

    config.cache_store = :null_store
  end

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Don"t care if the mailer can"t send.
  config.action_mailer.raise_delivery_errors = false

  # Disable caching for Action Mailer templates even if Action Controller
  # caching is enabled.
  config.action_mailer.perform_caching = false

  config.action_mailer.default_url_options = { host: "localhost", port: 3000 }

  # Print deprecation notices to the Rails logger.
  config.active_support.deprecation = :log

  # Raise exceptions for disallowed deprecations.
  config.active_support.disallowed_deprecation = :raise

  # Tell Active Support which deprecation messages to disallow.
  config.active_support.disallowed_deprecation_warnings = []

  # Raise an error on page load if there are pending migrations.
  config.active_record.migration_error = :page_load

  # Highlight code that triggered database queries in logs.
  config.active_record.verbose_query_logs = true

  # Highlight code that enqueued background job in logs.
  config.active_job.verbose_enqueue_logs = true

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  config.action_view.annotate_rendered_view_with_filenames = true

  # Uncomment if you wish to allow Action Cable access from any origin.
  # config.action_cable.disable_request_forgery_protection = true

  # Raise error when a before_action's only/except options reference missing actions.
  config.action_controller.raise_on_missing_callback_actions = true

  # Apply autocorrection by RuboCop to files generated by `bin/rails generate`.
  # config.generators.apply_rubocop_autocorrect_after_generate!

  # Set up Redis for caching and rate limiting
  config.cache_store = :redis_cache_store, { url: ENV.fetch("REDIS_URL", "redis://localhost:6379/0") }
end

================
File: config/environments/production.rb
================
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Code is not reloaded between requests.
  config.enable_reloading = false

  # Eager load code on boot. This eager loads most of Rails and
  # your application in memory, allowing both threaded web servers
  # and those relying on copy on write to perform better.
  # Rake tasks automatically ignore this option for performance.
  config.eager_load = true

  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local = false

  # Ensures that a master key has been made available in ENV[RAILS_MASTER_KEY], config/master.key, or an environment
  # key such as config/credentials/production.key. This key is used to decrypt credentials (and other encrypted files).
  # config.require_master_key = true

  # Disable serving static files from `public/`, relying on NGINX/Apache to do so instead.
  # config.public_file_server.enabled = false

  # Enable serving of images, stylesheets, and JavaScripts from an asset server.
  # config.asset_host = "http://assets.example.com"

  # Specifies the header that your server uses for sending files.
  # config.action_dispatch.x_sendfile_header = "X-Sendfile" # for Apache
  # config.action_dispatch.x_sendfile_header = "X-Accel-Redirect" # for NGINX

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Mount Action Cable outside main process or domain.
  # config.action_cable.mount_path = nil
  # config.action_cable.url = "wss://example.com/cable"
  # config.action_cable.allowed_request_origins = [http://example.com", /http:\/\/example.*]

  # Assume all access to the app is happening through a SSL-terminating reverse proxy.
  # Can be used together with config.force_ssl for Strict-Transport-Security and secure cookies.
  # config.assume_ssl = true

  # Force all access to the app over SSL, use Strict-Transport-Security, and use secure cookies.
  config.force_ssl = true

  # Skip http-to-https redirect for the default health check endpoint.
  # config.ssl_options = { redirect: { exclude: ->(request) { request.path == "/up" } } }

  # Log to STDOUT by default
  config.logger = ActiveSupport::Logger.new(STDOUT)
    .tap  { |logger| logger.formatter = ::Logger::Formatter.new }
    .then { |logger| ActiveSupport::TaggedLogging.new(logger) }

  # Prepend all log lines with the following tags.
  config.log_tags = [ :request_id ]

  # "info" includes generic and useful information about system operation, but avoids logging too much
  # information to avoid inadvertent exposure of personally identifiable information (PII). If you
  # want to log everything, set the level to "debug".
  config.log_level = ENV.fetch("RAILS_LOG_LEVEL", "info")

  # Use a different cache store in production.
  # config.cache_store = :mem_cache_store

  # Use a real queuing backend for Active Job (and separate queues per environment).
  # config.active_job.queue_adapter = :resque
  # config.active_job.queue_name_prefix = "tiny_api_production"

  # Disable caching for Action Mailer templates even if Action Controller
  # caching is enabled.
  config.action_mailer.perform_caching = false

  # Ignore bad email addresses and do not raise email delivery errors.
  # Set this to true and configure the email server for immediate delivery to raise delivery errors.
  # config.action_mailer.raise_delivery_errors = false

  # Enable locale fallbacks for I18n (makes lookups for any locale fall back to
  # the I18n.default_locale when a translation cannot be found).
  config.i18n.fallbacks = true

  # Don't log any deprecations.
  config.active_support.report_deprecations = false

  # Do not dump schema after migrations.
  config.active_record.dump_schema_after_migration = false

  # Enable DNS rebinding protection and other `Host` header attacks.
  # config.hosts = [
  #   "example.com",     # Allow requests from example.com
  #   /.*\.example\.com/ # Allow requests from subdomains like `www.example.com`
  # ]
  # Skip DNS rebinding protection for the default health check endpoint.
  # config.host_authorization = { exclude: ->(request) { request.path == "/up" } }

  # config.active_record.database_selector = { delay: 2.seconds }
  # config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver
  # config.active_record.database_resolver_context = ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  # ]
  # Skip DNS rebinding protection for the default health check endpoint.
  # config.host_authorization = { exclude: ->(request) { request.path == "/up" } }
end

================
File: config/environments/test.rb
================
require "active_support/core_ext/integer/time"

# The test environment is used exclusively to run your application"s
# test suite. You never need to work with it otherwise. Remember that
# your test database is "scratch space" for the test suite and is wiped
# and recreated between test runs. Don"t rely on the data there!

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # While tests run files are not watched, reloading is not necessary.
  config.enable_reloading = false

  # Eager loading loads your entire application. When running a single test locally,
  # this is usually not necessary, and can slow down your test suite. However, it"s
  # recommended that you enable it in continuous integration systems to ensure eager
  # loading is working properly before deploying your code.
  config.eager_load = ENV["CI"].present?

  # Configure public file server for tests with Cache-Control for performance.
  config.public_file_server.headers = { "Cache-Control" => "public, max-age=#{1.hour.to_i}" }

  # Show full error reports and disable caching.
  config.consider_all_requests_local = true
  config.action_controller.perform_caching = false
  config.cache_store = :null_store

  # Render exception templates for rescuable exceptions and raise for other exceptions.
  config.action_dispatch.show_exceptions = :rescuable

  # Disable request forgery protection in test environment.
  config.action_controller.allow_forgery_protection = false

  # Store uploaded files on the local file system in a temporary directory.
  config.active_storage.service = :test

  # Disable caching for Action Mailer templates even if Action Controller
  # caching is enabled.
  config.action_mailer.perform_caching = false

  # Tell Action Mailer not to deliver emails to the real world.
  # The :test delivery method accumulates sent emails in the
  # ActionMailer::Base.deliveries array.
  config.action_mailer.delivery_method = :test

  # Unlike controllers, the mailer instance doesn"t have any context about the
  # incoming request so you"ll need to provide the :host parameter yourself.
  config.action_mailer.default_url_options = { host: "www.example.com" }

  # Print deprecation notices to the stderr.
  config.active_support.deprecation = :stderr

  # Raise exceptions for disallowed deprecations.
  config.active_support.disallowed_deprecation = :raise

  # Tell Active Support which deprecation messages to disallow.
  config.active_support.disallowed_deprecation_warnings = []

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  # config.action_view.annotate_rendered_view_with_filenames = true

  # Raise error when a before_action"s only/except options reference missing actions.
  config.action_controller.raise_on_missing_callback_actions = true

  # Use Redis cache store for tests
  config.cache_store = :redis_cache_store, { url: ENV.fetch("REDIS_URL", "redis://localhost:6379/0") }
end

================
File: config/initializers/filter_parameter_logging.rb
================
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += [
  :passw, :email, :secret, :token, :_key, :crypt, :salt, :certificate, :otp, :ssn
]

================
File: config/initializers/inflections.rb
================
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end

================
File: config/initializers/scheduler.rb
================
require "rufus-scheduler"

scheduler = Rufus::Scheduler.singleton

scheduler.every "1h" do
  AutoDeleteExpiredPayloadsJob.perform_later
end

================
File: config/initializers/tinyapi_config.rb
================
Rails.application.config.tinyapi = ActiveSupport::OrderedOptions.new
Rails.application.config.tinyapi.max_payload_size = 10.megabytes
Rails.application.config.tinyapi.default_expiry_days = 7
Rails.application.config.tinyapi.max_expiry_days = 30
Rails.application.config.tinyapi.rate_limits = {
  add: 100,
  edit: 50,
  get: 1000
}

================
File: config/locales/en.yml
================
# Files in the config/locales directory are used for internationalization and
# are automatically loaded by Rails. If you want to use locales other than
# English, add the necessary files in this directory.
#
# To use the locales, use `I18n.t`:
#
#     I18n.t "hello"
#
# In views, this is aliased to just `t`:
#
#     <%= t("hello") %>
#
# To use a different locale, set it with `I18n.locale`:
#
#     I18n.locale = :es
#
# This would use the information in config/locales/es.yml.
#
# To learn more about the API, please read the Rails Internationalization guide
# at https://guides.rubyonrails.org/i18n.html.
#
# Be aware that YAML interprets the following case-insensitive strings as
# booleans: `true`, `false`, `on`, `off`, `yes`, `no`. Therefore, these strings
# must be quoted to be interpreted as strings. For example:
#
#     en:
#       "yes": yup
#       enabled: "ON"

en:
  hello: "Hello world"

================
File: config/puma.rb
================
# This configuration file will be evaluated by Puma. The top-level methods that
# are part of Puma"s configuration DSL. For more information
# about methods provided by the DSL, see https://puma.io/puma/Puma/DSL.html.

# Puma starts a configurable number of processes (workers) and each process
# serves each request in a thread from an internal thread pool.
#
# The ideal number of threads per worker depends both on how much time the
# application spends waiting for IO operations and on how much you wish to
# to prioritize throughput over latency.
#
# As a rule of thumb, increasing the number of threads will increase how much
# traffic a given process can handle (throughput), but due to CRuby"s
# Global VM Lock (GVL) it has diminishing returns and will degrade the
# response time (latency) of the application.
#
# The default is set to 3 threads as it"s deemed a decent compromise between
# throughput and latency for the average Rails application.
#
# Any libraries that use a connection pool or another resource pool should
# be configured to provide at least as many connections as the number of
# threads. This includes Active Record"s `pool` parameter in `database.yml`.
threads_count = ENV.fetch("RAILS_MAX_THREADS", 3)
threads threads_count, threads_count

# Specifies the `port` that Puma will listen on to receive requests; default is 3000.
port ENV.fetch("PORT", 3000)

# Allow puma to be restarted by `bin/rails restart` command.
plugin :tmp_restart

# Specify the PID file. Defaults to tmp/pids/server.pid in development.
# In other environments, only set the PID file if requested.
pidfile ENV["PIDFILE"] if ENV["PIDFILE"]

================
File: config/routes.rb
================
Rails.application.routes.draw do
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

  # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.
  # Can be used by load balancers and uptime monitors to verify that the app is live.
  get "up" => "rails/health#show", as: :rails_health_check

  # Defines the root path route ("/")
  # root "posts#index"

  namespace :api do
    namespace :v1 do
      resources :payloads, only: [ :create, :update, :show ], param: :hash_id
    end
  end

  resources :payloads, only: [ :index, :show, :create, :update ]
end

================
File: config/storage.yml
================
test:
  service: Disk
  root: <%= Rails.root.join("tmp/storage") %>

local:
  service: Disk
  root: <%= Rails.root.join("storage") %>

# Use bin/rails credentials:edit to set the AWS secrets (as aws:access_key_id|secret_access_key)
# amazon:
#   service: S3
#   access_key_id: <%= Rails.application.credentials.dig(:aws, :access_key_id) %>
#   secret_access_key: <%= Rails.application.credentials.dig(:aws, :secret_access_key) %>
#   region: us-east-1
#   bucket: your_own_bucket-<%= Rails.env %>

# Remember not to checkin your GCS keyfile to a repository
# google:
#   service: GCS
#   project: your_project
#   credentials: <%= Rails.root.join("path/to/gcs.keyfile") %>
#   bucket: your_own_bucket-<%= Rails.env %>

# Use bin/rails credentials:edit to set the Azure Storage secret (as azure_storage:storage_access_key)
# microsoft:
#   service: AzureStorage
#   storage_account_name: your_account_name
#   storage_access_key: <%= Rails.application.credentials.dig(:azure_storage, :storage_access_key) %>
#   container: your_container_name-<%= Rails.env %>

# mirror:
#   service: Mirror
#   primary: local
#   mirrors: [ amazon, google, microsoft ]

================
File: db/migrate/20240828072951_create_payloads.rb
================
class CreatePayloads < ActiveRecord::Migration[7.2]
  def change
    create_table :payloads do |t|
      t.string :hash_id
      t.text :content
      t.string :mime_type
      t.datetime :expiry_time
      t.datetime :viewed_at

      t.timestamps
    end
  end
end

================
File: db/migrate/YYYYMMDDHHMMSS_add_index_to_payloads.rb
================
class AddIndexToPayloads < ActiveRecord::Migration[7.2]
  def change
    add_index :payloads, :id
  end
end

================
File: db/migrate/YYYYMMDDHHMMSS_create_payloads.rb
================
class CreatePayloads < ActiveRecord::Migration[7.2]
  def change
    create_table :payloads do |t|
      t.string :hash_id
      t.text :content
      t.string :mime_type
      t.datetime :expiry_time
      t.datetime :viewed_at

      t.timestamps
    end
  end
end

================
File: db/schema.rb
================
# This file is auto-generated from the current state of the database. Instead
# of editing this file, please use the migrations feature of Active Record to
# incrementally modify your database, and then regenerate this schema definition.
#
# This file is the source Rails uses to define your schema when running `bin/rails
# db:schema:load`. When creating a new database, `bin/rails db:schema:load` tends to
# be faster and is potentially less error prone than running all of your
# migrations from scratch. Old migrations may fail to apply correctly if those
# migrations use external dependencies or application code.
#
# It's strongly recommended that you check this file into your version control system.

ActiveRecord::Schema[7.2].define(version: 2024_08_28_072951) do
  create_table "payloads", force: :cascade do |t|
    t.string "hash_id"
    t.text "content"
    t.string "mime_type"
    t.datetime "expiry_time"
    t.datetime "viewed_at"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end

================
File: db/seeds.rb
================
# This file should ensure the existence of records required to run the application in every environment (production,
# development, test). The code here should be idempotent so that it can be executed at any point in every environment.
# The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).
#
# Example:
#
#   [Action", "Comedy", "Drama", "Horror].each do |genre_name|
#     MovieGenre.find_or_create_by!(name: genre_name)
#   end

================
File: Dockerfile
================
# syntax = docker/dockerfile:1

# This Dockerfile is designed for production, not development. Use with Kamal or build'n'run by hand:
# docker build -t my-app .
# docker run -d -p 80:80 -p 443:443 --name my-app -e RAILS_MASTER_KEY=<value from config/master.key> my-app

# Make sure RUBY_VERSION matches the Ruby version in .ruby-version
ARG RUBY_VERSION=3.3.4
FROM docker.io/library/ruby:$RUBY_VERSION-slim AS base

# Rails app lives here
WORKDIR /rails

# Install base packages
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y curl libjemalloc2 libvips sqlite3 && \
    rm -rf /var/lib/apt/lists /var/cache/apt/archives

# Set production environment
ENV RAILS_ENV="production" \
    BUNDLE_DEPLOYMENT="1" \
    BUNDLE_PATH="/usr/local/bundle" \
    BUNDLE_WITHOUT="development"

# Throw-away build stage to reduce size of final image
FROM base AS build

# Install packages needed to build gems
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y build-essential git pkg-config && \
    rm -rf /var/lib/apt/lists /var/cache/apt/archives

# Install application gems
COPY Gemfile Gemfile.lock ./
RUN bundle install && \
    rm -rf ~/.bundle/ "${BUNDLE_PATH}"/ruby/*/cache "${BUNDLE_PATH}"/ruby/*/bundler/gems/*/.git && \
    bundle exec bootsnap precompile --gemfile

# Copy application code
COPY . .

# Precompile bootsnap code for faster boot times
RUN bundle exec bootsnap precompile app/ lib/

# Adjust binfiles to be executable on Linux
RUN chmod +x bin/* && \
    sed -i "s/\r$//g" bin/* && \
    sed -i 's/ruby\.exe$/ruby/' bin/*

# Final stage for app image
FROM base

# Copy built artifacts: gems, application
COPY --from=build "${BUNDLE_PATH}" "${BUNDLE_PATH}"
COPY --from=build /rails /rails

# Create necessary directories
RUN mkdir -p tmp/pids tmp/sockets log storage

# Run and own only the runtime files as a non-root user for security
RUN groupadd --system --gid 1000 rails && \
    useradd rails --uid 1000 --gid 1000 --create-home --shell /bin/bash && \
    chown -R rails:rails db log storage tmp
USER 1000:1000

# Entrypoint prepares the database.
ENTRYPOINT ["/rails/bin/docker-entrypoint"]

# Start the server by default, this can be overwritten at runtime
EXPOSE 3000
CMD ["./bin/rails", "server"]

================
File: Gemfile
================
source "https://rubygems.org"
git_source(:github) { |repo| "https://github.com/#{repo}.git" }

ruby "3.3.4"

# Bundle edge Rails instead: gem "rails", github: "rails/rails", branch: "main"
gem "rails", "~> 7.2.1"
# Use sqlite3 as the database for Active Record
gem "sqlite3"
# Use the Puma web server [https://github.com/puma/puma]
gem "puma"
# Build JSON APIs with ease [https://github.com/rails/jbuilder]
# gem "jbuilder"
# Use Redis adapter to run Action Cable in production
# gem "redis", ">= 4.0.1"
gem "redis"
# Use Active Model has_secure_password [https://guides.rubyonrails.org/active_model_basics.html#securepassword]
# gem "bcrypt", "~> 3.1.7"
gem "bcrypt"
# Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem "tzinfo-data", platforms: %i[ windows jruby ]
# Reduces boot times through caching; required in config/boot.rb
gem "bootsnap", require: false
# Add these gems
gem "dotenv-rails"
gem "rufus-scheduler"

# Use Active Storage variants [https://guides.rubyonrails.org/active_storage_overview.html#transforming-images]
# gem "image_processing", "~> 1.2"

# Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin Ajax possible
# gem "rack-cors"

group :development, :test do
  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem
  gem "debug", platforms: %i[ mri windows ], require: "debug/prelude"
  gem "rspec-rails"
  gem "factory_bot_rails"
  gem "shoulda-matchers"
end

group :development do
  # Static analysis for security vulnerabilities [https://brakemanscanner.org/]
  gem "brakeman"
  gem "rubocop-rails-omakase", require: false
end

gem "rubocop", require: false

# Add importmap-rails
gem "importmap-rails"

group :test do
  gem "simplecov", require: false
  gem "simplecov-cobertura"
end

================
File: Gemfile.lock
================
GEM
  remote: https://rubygems.org/
  specs:
    actioncable (7.2.1)
      actionpack (= 7.2.1)
      activesupport (= 7.2.1)
      nio4r (~> 2.0)
      websocket-driver (>= 0.6.1)
      zeitwerk (~> 2.6)
    actionmailbox (7.2.1)
      actionpack (= 7.2.1)
      activejob (= 7.2.1)
      activerecord (= 7.2.1)
      activestorage (= 7.2.1)
      activesupport (= 7.2.1)
      mail (>= 2.8.0)
    actionmailer (7.2.1)
      actionpack (= 7.2.1)
      actionview (= 7.2.1)
      activejob (= 7.2.1)
      activesupport (= 7.2.1)
      mail (>= 2.8.0)
      rails-dom-testing (~> 2.2)
    actionpack (7.2.1)
      actionview (= 7.2.1)
      activesupport (= 7.2.1)
      nokogiri (>= 1.8.5)
      racc
      rack (>= 2.2.4, < 3.2)
      rack-session (>= 1.0.1)
      rack-test (>= 0.6.3)
      rails-dom-testing (~> 2.2)
      rails-html-sanitizer (~> 1.6)
      useragent (~> 0.16)
    actiontext (7.2.1)
      actionpack (= 7.2.1)
      activerecord (= 7.2.1)
      activestorage (= 7.2.1)
      activesupport (= 7.2.1)
      globalid (>= 0.6.0)
      nokogiri (>= 1.8.5)
    actionview (7.2.1)
      activesupport (= 7.2.1)
      builder (~> 3.1)
      erubi (~> 1.11)
      rails-dom-testing (~> 2.2)
      rails-html-sanitizer (~> 1.6)
    activejob (7.2.1)
      activesupport (= 7.2.1)
      globalid (>= 0.3.6)
    activemodel (7.2.1)
      activesupport (= 7.2.1)
    activerecord (7.2.1)
      activemodel (= 7.2.1)
      activesupport (= 7.2.1)
      timeout (>= 0.4.0)
    activestorage (7.2.1)
      actionpack (= 7.2.1)
      activejob (= 7.2.1)
      activerecord (= 7.2.1)
      activesupport (= 7.2.1)
      marcel (~> 1.0)
    activesupport (7.2.1)
      base64
      bigdecimal
      concurrent-ruby (~> 1.0, >= 1.3.1)
      connection_pool (>= 2.2.5)
      drb
      i18n (>= 1.6, < 2)
      logger (>= 1.4.2)
      minitest (>= 5.1)
      securerandom (>= 0.3)
      tzinfo (~> 2.0, >= 2.0.5)
    ast (2.4.2)
    base64 (0.2.0)
    bcrypt (3.1.20)
    bigdecimal (3.1.8)
    bootsnap (1.18.4)
      msgpack (~> 1.2)
    brakeman (6.2.1)
      racc
    builder (3.3.0)
    concurrent-ruby (1.3.4)
    connection_pool (2.4.1)
    crass (1.0.6)
    date (3.3.4)
    debug (1.9.2)
      irb (~> 1.10)
      reline (>= 0.3.8)
    diff-lcs (1.5.1)
    docile (1.4.1)
    dotenv (3.1.2)
    dotenv-rails (3.1.2)
      dotenv (= 3.1.2)
      railties (>= 6.1)
    drb (2.2.1)
    erubi (1.13.0)
    et-orbi (1.2.11)
      tzinfo
    factory_bot (6.4.6)
      activesupport (>= 5.0.0)
    factory_bot_rails (6.4.3)
      factory_bot (~> 6.4)
      railties (>= 5.0.0)
    fugit (1.11.1)
      et-orbi (~> 1, >= 1.2.11)
      raabro (~> 1.4)
    globalid (1.2.1)
      activesupport (>= 6.1)
    i18n (1.14.5)
      concurrent-ruby (~> 1.0)
    importmap-rails (2.0.1)
      actionpack (>= 6.0.0)
      activesupport (>= 6.0.0)
      railties (>= 6.0.0)
    io-console (0.7.2)
    irb (1.14.0)
      rdoc (>= 4.0.0)
      reline (>= 0.4.2)
    json (2.7.2)
    language_server-protocol (3.17.0.3)
    logger (1.6.0)
    loofah (2.22.0)
      crass (~> 1.0.2)
      nokogiri (>= 1.12.0)
    mail (2.8.1)
      mini_mime (>= 0.1.1)
      net-imap
      net-pop
      net-smtp
    marcel (1.0.4)
    mini_mime (1.1.5)
    minitest (5.25.1)
    msgpack (1.7.2)
    net-imap (0.4.15)
      date
      net-protocol
    net-pop (0.1.2)
      net-protocol
    net-protocol (0.2.2)
      timeout
    net-smtp (0.5.0)
      net-protocol
    nio4r (2.7.3)
    nokogiri (1.16.7-x64-mingw-ucrt)
      racc (~> 1.4)
    nokogiri (1.16.7-x86_64-linux)
      racc (~> 1.4)
    parallel (1.26.3)
    parser (3.3.4.2)
      ast (~> 2.4.1)
      racc
    psych (5.1.2)
      stringio
    puma (6.4.2)
      nio4r (~> 2.0)
    raabro (1.4.0)
    racc (1.8.1)
    rack (3.1.7)
    rack-session (2.0.0)
      rack (>= 3.0.0)
    rack-test (2.1.0)
      rack (>= 1.3)
    rackup (2.1.0)
      rack (>= 3)
      webrick (~> 1.8)
    rails (7.2.1)
      actioncable (= 7.2.1)
      actionmailbox (= 7.2.1)
      actionmailer (= 7.2.1)
      actionpack (= 7.2.1)
      actiontext (= 7.2.1)
      actionview (= 7.2.1)
      activejob (= 7.2.1)
      activemodel (= 7.2.1)
      activerecord (= 7.2.1)
      activestorage (= 7.2.1)
      activesupport (= 7.2.1)
      bundler (>= 1.15.0)
      railties (= 7.2.1)
    rails-dom-testing (2.2.0)
      activesupport (>= 5.0.0)
      minitest
      nokogiri (>= 1.6)
    rails-html-sanitizer (1.6.0)
      loofah (~> 2.21)
      nokogiri (~> 1.14)
    railties (7.2.1)
      actionpack (= 7.2.1)
      activesupport (= 7.2.1)
      irb (~> 1.13)
      rackup (>= 1.0.0)
      rake (>= 12.2)
      thor (~> 1.0, >= 1.2.2)
      zeitwerk (~> 2.6)
    rainbow (3.1.1)
    rake (13.2.1)
    rdoc (6.7.0)
      psych (>= 4.0.0)
    redis (5.3.0)
      redis-client (>= 0.22.0)
    redis-client (0.22.2)
      connection_pool
    regexp_parser (2.9.2)
    reline (0.5.9)
      io-console (~> 0.5)
    rexml (3.3.6)
      strscan
    rspec-core (3.13.0)
      rspec-support (~> 3.13.0)
    rspec-expectations (3.13.2)
      diff-lcs (>= 1.2.0, < 2.0)
      rspec-support (~> 3.13.0)
    rspec-mocks (3.13.1)
      diff-lcs (>= 1.2.0, < 2.0)
      rspec-support (~> 3.13.0)
    rspec-rails (6.1.4)
      actionpack (>= 6.1)
      activesupport (>= 6.1)
      railties (>= 6.1)
      rspec-core (~> 3.13)
      rspec-expectations (~> 3.13)
      rspec-mocks (~> 3.13)
      rspec-support (~> 3.13)
    rspec-support (3.13.1)
    rubocop (1.65.1)
      json (~> 2.3)
      language_server-protocol (>= 3.17.0)
      parallel (~> 1.10)
      parser (>= 3.3.0.2)
      rainbow (>= 2.2.2, < 4.0)
      regexp_parser (>= 2.4, < 3.0)
      rexml (>= 3.2.5, < 4.0)
      rubocop-ast (>= 1.31.1, < 2.0)
      ruby-progressbar (~> 1.7)
      unicode-display_width (>= 2.4.0, < 3.0)
    rubocop-ast (1.32.1)
      parser (>= 3.3.1.0)
    rubocop-minitest (0.35.1)
      rubocop (>= 1.61, < 2.0)
      rubocop-ast (>= 1.31.1, < 2.0)
    rubocop-performance (1.21.1)
      rubocop (>= 1.48.1, < 2.0)
      rubocop-ast (>= 1.31.1, < 2.0)
    rubocop-rails (2.26.0)
      activesupport (>= 4.2.0)
      rack (>= 1.1)
      rubocop (>= 1.52.0, < 2.0)
      rubocop-ast (>= 1.31.1, < 2.0)
    rubocop-rails-omakase (1.0.0)
      rubocop
      rubocop-minitest
      rubocop-performance
      rubocop-rails
    ruby-progressbar (1.13.0)
    rufus-scheduler (3.9.1)
      fugit (~> 1.1, >= 1.1.6)
    securerandom (0.3.1)
    shoulda-matchers (6.4.0)
      activesupport (>= 5.2.0)
    simplecov (0.22.0)
      docile (~> 1.1)
      simplecov-html (~> 0.11)
      simplecov_json_formatter (~> 0.1)
    simplecov-cobertura (2.1.0)
      rexml
      simplecov (~> 0.19)
    simplecov-html (0.12.3)
    simplecov_json_formatter (0.1.4)
    sqlite3 (2.0.4-x64-mingw-ucrt)
    sqlite3 (2.0.4-x86_64-linux-gnu)
    stringio (3.1.1)
    strscan (3.1.0)
    thor (1.3.1)
    timeout (0.4.1)
    tzinfo (2.0.6)
      concurrent-ruby (~> 1.0)
    tzinfo-data (1.2024.1)
      tzinfo (>= 1.0.0)
    unicode-display_width (2.5.0)
    useragent (0.16.10)
    webrick (1.8.1)
    websocket-driver (0.7.6)
      websocket-extensions (>= 0.1.0)
    websocket-extensions (0.1.5)
    zeitwerk (2.6.17)

PLATFORMS
  x64-mingw-ucrt
  x86_64-linux

DEPENDENCIES
  bcrypt
  bootsnap
  brakeman
  debug
  dotenv-rails
  factory_bot_rails
  importmap-rails
  puma
  rails (~> 7.2.1)
  redis
  rspec-rails
  rubocop
  rubocop-rails-omakase
  rufus-scheduler
  shoulda-matchers
  simplecov
  simplecov-cobertura
  sqlite3
  tzinfo-data

RUBY VERSION
   ruby 3.3.4p94

BUNDLED WITH
   2.5.11

================
File: LICENSE.md
================
MIT License

Copyright (c) 2024 Narayan Babu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: progress.md
================
# TinyAPI Progress

## Completed Tasks
- Set up Rails project with necessary gems
- Created Payload model and migration
- Implemented rate limiting with Redis
- Created PayloadsController with add, edit, and get actions
- Set up configuration for expiry times and rate limits
- Implemented auto-delete job for expired payloads
- Added scheduler for running the auto-delete job
- Fixed database migration issues
- Implemented CRUD operations with curl commands
- Created API documentation (API_DOCUMENTATION.md)
- Updated expiry time logic to respect server-defined maximum
- Added README.md with project overview and setup instructions
- Added LICENSE.md with MIT License
- Updated .gitignore to exclude all sensitive and unnecessary files
- Removed tracked files that should be ignored
- Used git filter-repo to remove sensitive and unnecessary files from entire Git history
- Re-added remote origin after git filter-repo operation
- Set up RSpec for testing
- Created initial model tests for Payload
- Created controller tests for PayloadsController (add, edit, get actions)
- Implemented comprehensive tests using RSpec
  - Included model specs and controller specs
  - Used FactoryBot for test data generation
- Fixed issues with rate limiting in tests
- Configured test environment to use Redis for caching
- Wrote integration tests for API endpoints (add, edit, get)
- Successfully ran and passed all tests (unit, controller, and integration)
- Implemented error handling for database errors and not found scenarios
- Set up Rubocop for code style enforcement
- Optimized database queries
  - Added necessary indexes
  - Used includes, joins, or select to avoid N+1 queries
- Implemented caching strategies (e.g., fragment caching, Russian Doll caching)
- Refactored code to follow Ruby style guide (used Rubocop)
- Fixed all RuboCop offenses
- Ensured all tests are passing after refactoring
- Implemented API versioning (v1)
- Updated routes to use RESTful conventions
- Refactored PayloadsController to use create, update, and show actions
- Updated tests to match new API structure and conventions
- Fixed issues with update action in controller and tests
- Ensured all tests are passing after refactoring
- Updated API documentation to reflect new versioned endpoints
- Implemented comprehensive error handling in controller actions
- Added tests for non-existent payload scenarios
- Configured CI pipeline with GitHub Actions
- Set up linting with RuboCop in CI pipeline
- Implemented test coverage reporting

## To-Do
- Improve API documentation further
  - Add more detailed examples for each endpoint
  - Include error responses and status codes for all scenarios
- Implement versioning for the API (future versions)
- Add monitoring and alerting for production environment
- Enhance error handling and validation
  - Implement proper error logging
  - Display user-friendly error messages
- Refactor controllers to keep them skinny
  - Move business logic to service objects or model methods
- Add more comprehensive logging
- Implement pagination for large datasets
- Consider adding a delete endpoint for manual payload removal
- Use service objects for complex business logic
- Implement background jobs using Sidekiq for time-consuming tasks
- Set up Docker for consistent development and deployment environments
- Configure production environment
- Implement token validation (for future versions)
- Enhance security measures
  - Implement proper authentication and authorization
  - Use strong parameters in controllers
  - Protect against common web vulnerabilities (XSS, CSRF, SQL injection)

================
File: public/robots.txt
================
# See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file

================
File: Rakefile
================
# Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require_relative "config/application"

Rails.application.load_tasks

================
File: README.md
================
# TinyAPI

[![CI Status](https://github.com/codevalley/tinyapi/workflows/CI/badge.svg)](https://github.com/codevalley/tinyapi/actions)
[![codecov](https://codecov.io/gh/codevalley/tinyapi/branch/main/graph/badge.svg)](https://codecov.io/gh/codevalley/tinyapi)

TinyAPI is a simple storage service that allows users to save and edit payloads through a RESTful API. It's built with Ruby on Rails and uses Redis for rate limiting.

## Features

- Create, read, and update payloads
- Automatic payload expiration
- Rate limiting
- Configurable payload size and expiry time

## Getting Started

### Prerequisites

- Ruby 3.x
- Rails 7.2.1
- Redis

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/your-username/tinyapi.git
   cd tinyapi
   ```

2. Install dependencies:
   ```bash
   bundle install
   ```

3. Set up the database:
   ```bash
   rails db:create db:migrate
   ```

4. Start the Redis server:
   ```bash
   redis-server
   ```

5. Start the Rails server:
   ```bash
   rails server
   ```

## Usage

See [API_DOCUMENTATION.md](API_DOCUMENTATION.md) for detailed API usage instructions.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.

================
File: spec/controllers/api/v1/payloads_controller_spec.rb
================
require "rails_helper"

RSpec.describe Api::V1::PayloadsController, type: :controller do
  let(:valid_attributes) {
    { content: "Test content", mime_type: "text/plain", expiry_time: 1.day.from_now }
  }

  let(:invalid_attributes) {
    { content: "", mime_type: "", expiry_time: nil }
  }

  let(:valid_headers) {
    { "X-Client-Token" => "test_token" }
  }

  describe "POST #create" do
    context "with valid params" do
      it "creates a new Payload" do
        expect {
          request.headers.merge!(valid_headers)
          post :create, params: { payload: valid_attributes }
        }.to change(Payload, :count).by(1)
      end

      it "renders a JSON response with the new payload" do
        request.headers.merge!(valid_headers)
        post :create, params: { payload: valid_attributes }
        expect(response).to have_http_status(:created)
        expect(response.content_type).to eq("application/json; charset=utf-8")
        expect(JSON.parse(response.body)).to include("hash_id", "content", "mime_type", "expiry_time")
      end
    end

    context "with invalid params" do
      it "renders a JSON response with errors" do
        request.headers.merge!(valid_headers)
        post :create, params: { payload: invalid_attributes }
        expect(response).to have_http_status(:unprocessable_entity)
        expect(response.content_type).to eq("application/json; charset=utf-8")
        expect(JSON.parse(response.body)).to have_key("errors")
      end
    end
  end

  describe "PUT #update" do
    let!(:payload) { create(:payload) }

    context "with valid params" do
      let(:new_attributes) {
        { content: "Updated content" }
      }

      it "updates the requested payload" do
        request.headers.merge!(valid_headers)
        put :update, params: { hash_id: payload.hash_id, payload: new_attributes }
        payload.reload
        expect(payload.content).to eq("Updated content")
      end

      it "renders a JSON response with the payload" do
        request.headers.merge!(valid_headers)
        put :update, params: { hash_id: payload.hash_id, payload: new_attributes }
        expect(response).to have_http_status(:ok)
        expect(response.content_type).to eq("application/json; charset=utf-8")
        expect(JSON.parse(response.body)["content"]).to eq("Updated content")
      end
    end

    context "with invalid params" do
      it "renders a JSON response with errors" do
        request.headers.merge!(valid_headers)
        put :update, params: { hash_id: payload.hash_id, payload: invalid_attributes }
        expect(response).to have_http_status(:unprocessable_entity)
        expect(response.content_type).to eq("application/json; charset=utf-8")
        expect(JSON.parse(response.body)).to have_key("errors")
      end
    end

    context "with non-existent payload" do
      it "renders a JSON response with a not found error" do
        request.headers.merge!(valid_headers)
        put :update, params: { hash_id: "non_existent", payload: valid_attributes }
        expect(response).to have_http_status(:not_found)
        expect(response.content_type).to eq("application/json; charset=utf-8")
        expect(JSON.parse(response.body)).to have_key("error")
      end
    end
  end

  describe "GET #show" do
    let!(:payload) { create(:payload) }

    it "renders a JSON response with the payload" do
      request.headers.merge!(valid_headers)
      get :show, params: { hash_id: payload.hash_id }
      expect(response).to have_http_status(:ok)
      expect(response.content_type).to eq("application/json; charset=utf-8")
      expect(JSON.parse(response.body)).to include("hash_id", "content", "mime_type", "expiry_time")
    end

    it "updates the viewed_at timestamp" do
      expect {
        request.headers.merge!(valid_headers)
        get :show, params: { hash_id: payload.hash_id }
        payload.reload
      }.to change(payload, :viewed_at)
    end

    context "when payload doesn't exist" do
      it "renders a JSON response with errors" do
        request.headers.merge!(valid_headers)
        get :show, params: { hash_id: "nonexistent" }
        expect(response).to have_http_status(:not_found)
        expect(response.content_type).to eq("application/json; charset=utf-8")
        expect(JSON.parse(response.body)).to have_key("error")
      end
    end
  end
end

================
File: spec/factories/payloads.rb
================
FactoryBot.define do
  factory :payload do
    hash_id { SecureRandom.hex(10) }
    content { "Test content" }
    mime_type { "text/plain" }
    expiry_time { 1.day.from_now }
  end
end

================
File: spec/models/payload_spec.rb
================
require "rails_helper"

RSpec.describe Payload, type: :model do
  describe "validations" do
    subject { Payload.new(content: "Test content") }

    it { should validate_presence_of(:content) }

    it "validates presence of hash_id" do
      payload = Payload.new(content: "Test content", skip_callbacks: true)
      expect(payload).to be_invalid
      expect(payload.errors[:hash_id]).to include("can't be blank")
    end

    it "validates presence of mime_type" do
      payload = Payload.new(content: "Test content", skip_callbacks: true)
      expect(payload).to be_invalid
      expect(payload.errors[:mime_type]).to include("can't be blank")
    end

    it { should validate_uniqueness_of(:hash_id) }

    it "sets a default mime_type if not provided" do
      payload = Payload.new(content: "Test content")
      payload.valid?
      expect(payload.mime_type).to eq("text/plain")
    end

    it "sets a default hash_id if not provided" do
      payload = Payload.new(content: "Test content")
      payload.valid?
      expect(payload.hash_id).to be_present
    end

    it "sets a default expiry_time if not provided" do
      payload = Payload.new(content: "Test content")
      payload.valid?
      expect(payload.expiry_time).to be_within(1.second).of(30.days.from_now)
    end
  end

  describe "content_size_within_limit" do
    it "is invalid when content size exceeds the limit" do
      payload = Payload.new(content: "a" * (Payload::MAX_CONTENT_SIZE + 1))
      payload.valid?
      expect(payload.errors[:content]).to include("size exceeds the limit of #{Payload::MAX_CONTENT_SIZE} bytes")
    end

    it "is valid when content size is within the limit" do
      payload = Payload.new(content: "a" * Payload::MAX_CONTENT_SIZE)
      payload.valid?
      expect(payload.errors[:content]).to be_empty
    end
  end

  describe "expiry_time_within_limit" do
    it "sets expiry_time to the maximum allowed when it exceeds the limit" do
      payload = Payload.new(content: "Test", expiry_time: 31.days.from_now)
      payload.valid?
      expect(payload.expiry_time).to be_within(1.second).of(30.days.from_now)
    end

    it "does not change expiry_time when it's within the limit" do
      expiry_time = 29.days.from_now
      payload = Payload.new(content: "Test", expiry_time: expiry_time)
      payload.valid?
      expect(payload.expiry_time).to be_within(1.second).of(expiry_time)
    end
  end
end

================
File: spec/rails_helper.rb
================
# This file is copied to spec/ when you run "rails generate rspec:install"
require "spec_helper"
ENV["RAILS_ENV"] ||= "test"
require_relative "../config/environment"
# Prevent database truncation if the environment is production
abort("The Rails environment is running in production mode!") if Rails.env.production?
require "rspec/rails"
# Add additional requires below this line. Rails is not loaded until this point!

# Requires supporting ruby files with custom matchers and macros, etc, in
# spec/support/ and its subdirectories. Files matching `spec/**/*_spec.rb` are
# run as spec files by default. This means that files in spec/support that end
# in _spec.rb will both be required and run as specs, causing the specs to be
# run twice. It is recommended that you do not name files matching this glob to
# end with _spec.rb. You can configure this pattern with the --pattern
# option on the command line or in ~/.rspec, .rspec or `.rspec-local`.
#
# The following line is provided for convenience purposes. It has the downside
# of increasing the boot-up time by auto-requiring all files in the support
# directory. Alternatively, in the individual `*_spec.rb` files, manually
# require only the support files necessary.
#
# Rails.root.glob("spec/support/**/*.rb").sort.each { |f| require f }

# Checks for pending migrations and applies them before tests are run.
# If you are not using ActiveRecord, you can remove these lines.
begin
  ActiveRecord::Migration.maintain_test_schema!
rescue ActiveRecord::PendingMigrationError => e
  abort e.to_s.strip
end
RSpec.configure do |config|
  # Remove this line if you"re not using ActiveRecord or ActiveRecord fixtures
  config.fixture_paths = [
    Rails.root.join("spec/fixtures")
]

  # If you"re not using ActiveRecord, or you'd prefer not to run each of your
  # examples within a transaction, remove the following line or assign false
  # instead of true.
  config.use_transactional_fixtures = true

  # You can uncomment this line to turn off ActiveRecord support entirely.
  # config.use_active_record = false

  # RSpec Rails can automatically mix in different behaviours to your tests
  # based on their file location, for example enabling you to call `get` and
  # `post` in specs under `spec/controllers`.
  #
  # You can disable this behaviour by removing the line below, and instead
  # explicitly tag your specs with their type, e.g.:
  #
  #     RSpec.describe UsersController, type: :controller do
  #       # ...
  #     end
  #
  # The different available types are documented in the features, such as in
  # https://rspec.info/features/6-0/rspec-rails
  config.infer_spec_type_from_file_location!

  # Filter lines from Rails gems in backtraces.
  config.filter_rails_from_backtrace!
  # arbitrary gems may also be filtered via:
  # config.filter_gems_from_backtrace("gem name")

  # Include FactoryBot methods
  config.include FactoryBot::Syntax::Methods
end

# Configure Shoulda Matchers
Shoulda::Matchers.configure do |config|
  config.integrate do |with|
    with.test_framework :rspec
    with.library :rails
  end
end

================
File: spec/requests/api/v1/payloads_spec.rb
================
require "rails_helper"

RSpec.describe "Api::V1::Payloads", type: :request do
  let(:valid_attributes) {
    { content: "Test content", mime_type: "text/plain", expiry_time: 1.day.from_now }
  }

  let(:invalid_attributes) {
    { content: "", mime_type: "", expiry_time: nil }
  }

  let(:valid_headers) {
    { "X-Client-Token" => "test_token", "CONTENT_TYPE" => "application/json" }
  }

  describe "POST /api/v1/payloads" do
    context "with valid parameters" do
      it "creates a new Payload" do
        expect {
          post api_v1_payloads_path, params: { payload: valid_attributes }.to_json, headers: valid_headers
        }.to change(Payload, :count).by(1)
        expect(response).to have_http_status(:created)
      end
    end

    context "with invalid parameters" do
      it "does not create a new Payload" do
        post api_v1_payloads_path, params: { payload: invalid_attributes }.to_json, headers: valid_headers
        expect(response).to have_http_status(:unprocessable_entity)
      end
    end
  end

  describe "PUT /api/v1/payloads/:hash_id" do
    let!(:payload) { create(:payload) }

    context "with valid parameters" do
      let(:new_attributes) { { content: "Updated content" } }

      it "updates the requested payload" do
        put api_v1_payload_path(payload.hash_id), params: { payload: new_attributes }.to_json, headers: valid_headers
        payload.reload
        expect(payload.content).to eq("Updated content")
        expect(response).to have_http_status(:ok)
      end
    end

    context "with invalid parameters" do
      it "renders a JSON response with errors" do
        put api_v1_payload_path(payload.hash_id), params: { payload: invalid_attributes }.to_json,
headers: valid_headers
        expect(response).to have_http_status(:unprocessable_entity)
      end
    end

    context "with non-existent payload" do
      it "renders a JSON response with a not found error" do
        put api_v1_payload_path("non_existent"), params: { payload: valid_attributes }.to_json, headers: valid_headers
        expect(response).to have_http_status(:not_found)
      end
    end
  end

  describe "GET /api/v1/payloads/:hash_id" do
    let!(:payload) { create(:payload) }

    it "renders a successful response" do
      get api_v1_payload_path(payload.hash_id), headers: valid_headers
      expect(response).to be_successful
    end

    it "updates the viewed_at timestamp" do
      expect {
        get api_v1_payload_path(payload.hash_id), headers: valid_headers
        payload.reload
      }.to change(payload, :viewed_at)
    end
  end
end

================
File: spec/spec_helper.rb
================
# This file was generated by the `rails generate rspec:install` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
# Given that it is always loaded, you are encouraged to keep this file as
# light-weight as possible. Requiring heavyweight dependencies from this file
# will add to the boot time of your test suite on EVERY test run, even for an
# individual file that may not need all of that loaded. Instead, consider making
# a separate helper file that requires the additional dependencies and performs
# the additional setup, and require it from the spec files that actually need
# it.
#
# See https://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
require 'rails_helper'

RSpec.configure do |config|
  # rspec-expectations config goes here. You can use an alternate
  # assertion/expectation library such as wrong or the stdlib/minitest
  # assertions if you prefer.
  config.expect_with :rspec do |expectations|
    # This option will default to `true` in RSpec 4. It makes the `description`
    # and `failure_message` of custom matchers include text for helper methods
    # defined using `chain`, e.g.:
    #     be_bigger_than(2).and_smaller_than(4).description
    #     # => "be bigger than 2 and smaller than 4"
    # ...rather than:
    #     # => "be bigger than 2"
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  # rspec-mocks config goes here. You can use an alternate test double
  # library (such as bogus or mocha) by changing the `mock_with` option here.
  config.mock_with :rspec do |mocks|
    # Prevents you from mocking or stubbing a method that does not exist on
    # a real object. This is generally recommended, and will default to
    # `true` in RSpec 4.
    mocks.verify_partial_doubles = true
  end

  # This option will default to `:apply_to_host_groups` in RSpec 4 (and will
  # have no way to turn it off -- the option exists only for backwards
  # compatibility in RSpec 3). It causes shared context metadata to be
  # inherited by the metadata hash of host groups and examples, rather than
  # triggering implicit auto-inclusion in groups with matching metadata.
  config.shared_context_metadata_behavior = :apply_to_host_groups

  config.before(:suite) do
    raise "TinyAPI configuration not loaded" unless Rails.configuration.respond_to?(:tinyapi)
  end

# The settings below are suggested to provide a good initial experience
# with RSpec, but feel free to customize to your heart"s content.
=begin
  # This allows you to limit a spec run to individual examples or groups
  # you care about by tagging them with `:focus` metadata. When nothing
  # is tagged with `:focus`, all examples get run. RSpec also provides
  # aliases for `it`, `describe`, and `context` that include `:focus`
  # metadata: `fit`, `fdescribe` and `fcontext`, respectively.
  config.filter_run_when_matching :focus

  # Allows RSpec to persist some state between runs in order to support
  # the `--only-failures` and `--next-failure` CLI options. We recommend
  # you configure your source control system to ignore this file.
  config.example_status_persistence_file_path = "spec/examples.txt"

  # Limits the available syntax to the non-monkey patched syntax that is
  # recommended. For more details, see:
  # https://rspec.info/features/3-12/rspec-core/configuration/zero-monkey-patching-mode/
  config.disable_monkey_patching!

  # This setting enables warnings. It"s recommended, but in some cases may
  # be too noisy due to issues in dependencies.
  config.warnings = true

  # Many RSpec users commonly either run the entire suite or an individual
  # file, and it's useful to allow more verbose output when running an
  # individual spec file.
  if config.files_to_run.one?
    # Use the documentation formatter for detailed output,
    # unless a formatter has already been configured
    # (e.g. via a command-line flag).
    config.default_formatter = "doc"
  end

  # Print the 10 slowest examples and example groups at the
  # end of the spec run, to help surface which specs are running
  # particularly slow.
  config.profile_examples = 10

  # Run specs in random order to surface order dependencies. If you find an
  # order dependency and want to debug it, you can fix the order by providing
  # the seed, which is printed after each run.
  #     --seed 1234
  config.order = :random

  # Seed global randomization in this process using the `--seed` CLI option.
  # Setting this allows you to use `--seed` to deterministically reproduce
  # test failures related to randomization by passing the same `--seed` value
  # as the one that triggered the failure.
  Kernel.srand config.seed
=end
end

================
File: test/channels/application_cable/connection_test.rb
================
require "test_helper"

module ApplicationCable
  class ConnectionTest < ActionCable::Connection::TestCase
    # test "connects with cookies" do
    #   cookies.signed[user_i] = 42
    #
    #   connect
    #
    #   assert_equal connection.user_id, "42"
    # end
  end
end

================
File: test/controllers/concerns/error_handler_test.rb
================
require "test_helper"

class ErrorHandlerTest < ActionDispatch::IntegrationTest
  class TestController < ApplicationController
    include ErrorHandler

    def not_found
      raise ActiveRecord::RecordNotFound
    end

    def invalid_record
      payload = Payload.new
      payload.errors.add(:base, "Test error")
      raise ActiveRecord::RecordInvalid.new(payload)
    end

    def not_unique
      raise ActiveRecord::RecordNotUnique.new("Test error")
    end
  end

  setup do
    Rails.application.routes.draw do
      get "test/not_found" => "error_handler_test/test#not_found"
      get "test/invalid_record" => "error_handler_test/test#invalid_record"
      get "test/not_unique" => "error_handler_test/test#not_unique"
    end
  end

  teardown do
    Rails.application.reload_routes!
  end

  test "handles ActiveRecord::RecordNotFound" do
    get "/test/not_found"
    assert_response :not_found
    assert_equal({ "error" => "Resource not found" }, JSON.parse(@response.body))
  end

  test "handles ActiveRecord::RecordInvalid" do
    get "/test/invalid_record"
    assert_response :unprocessable_entity
    assert_includes JSON.parse(@response.body)["error"], "Test error"
  end

  test "handles ActiveRecord::RecordNotUnique" do
    get "/test/not_unique"
    assert_response :conflict
    assert_equal({ "error" => "Resource already exists" }, JSON.parse(@response.body))
  end
end

================
File: test/controllers/concerns/rate_limitable_test.rb
================
require "test_helper"

class RateLimitableTest < ActionDispatch::IntegrationTest
  class TestController < ApplicationController
    include RateLimitable

    def test_action
      render json: { message: "Success" }
    end
  end

  setup do
    Rails.application.routes.draw do
      get "test/rate_limit" => "rate_limitable_test/test#test_action"
    end
    Rails.configuration.tinyapi ||= OpenStruct.new
    Rails.configuration.tinyapi.rate_limits = { test_action: 2 }
    Rails.cache.clear
  end

  teardown do
    Rails.application.reload_routes!
    Rails.cache.clear
  end

  test "allows requests within rate limit" do
    2.times do
      get "/test/rate_limit", headers: { "X-Client-Token" => "test_token" }
      assert_response :success
    end
  end

  test "blocks requests exceeding rate limit" do
    3.times do |i|
      get "/test/rate_limit", headers: { "X-Client-Token" => "test_token" }
      if i < 2
        assert_response :success
      else
        assert_response :too_many_requests
        assert_equal({ "error" => "Rate limit exceeded" }, JSON.parse(@response.body))
      end
    end
  end

  test "handles Redis connection error" do
    original_increment = Rails.cache.method(:increment)
    Rails.cache.define_singleton_method(:increment) do |*args|
      raise Redis::CannotConnectError.new("Connection refused")
    end

    get "/test/rate_limit", headers: { "X-Client-Token" => "test_token" }
    assert_response :success

    Rails.cache.singleton_class.send(:remove_method, :increment)
    Rails.cache.define_singleton_method(:increment, original_increment)
  end
end

================
File: test/controllers/payloads_controller_test.rb
================
require "test_helper"

class PayloadsControllerTest < ActionDispatch::IntegrationTest
  setup do
    @payload = payloads(:one)
  end

  test "should get index" do
    get payloads_url, as: :json
    assert_response :success
    assert_not_empty JSON.parse(@response.body)
  end

  test "should create payload" do
    assert_difference("Payload.count") do
      post payloads_url, params: { payload: { content: "New content", mime_type: "text/plain" } }, as: :json
    end

    assert_response :created
    assert_not_nil JSON.parse(@response.body)["hash_id"]
  end

  test "should show payload" do
    get payload_url(@payload.hash_id), as: :json
    assert_response :success
    assert_equal @payload.content, JSON.parse(@response.body)["content"]
  end

  test "should update payload" do
    patch payload_url(@payload.hash_id),
          params: { payload: { content: "Updated content" } },
          as: :json
    assert_response :success
    assert_equal "Updated content", Payload.find_by(hash_id: @payload.hash_id).content
  end

  test "should not create payload with invalid params" do
    assert_no_difference("Payload.count") do
      post payloads_url, params: { payload: { content: nil } }, as: :json
    end

    assert_response :unprocessable_entity
  end

  test "should return not found for non-existent payload" do
    get payload_url("non-existent-id"), as: :json
    assert_response :not_found
  end

  test "should handle update with invalid params" do
    patch payload_url(@payload.hash_id),
          params: { payload: { content: "a" * (Payload::MAX_CONTENT_SIZE + 1) } },
          as: :json
    assert_response :unprocessable_entity
  end
end

================
File: test/fixtures/payloads.yml
================
one:
  hash_id: "abc123"
  content: "Test content"
  mime_type: "text/plain"
  expiry_time: <%= 1.day.from_now %>

two:
  hash_id: "def456"
  content: "Another test content"
  mime_type: "application/json"
  expiry_time: <%= 2.days.from_now %>

================
File: test/models/payload_test.rb
================
require "test_helper"

class PayloadTest < ActiveSupport::TestCase
  test "should not save payload without content" do
    payload = Payload.new
    assert_not payload.save, "Saved the payload without content"
  end

  test "should not save payload with content exceeding maximum length" do
    payload = Payload.new(content: "a" * (Payload::MAX_CONTENT_SIZE + 1))
    assert_not payload.save, "Saved the payload with content exceeding maximum length"
  end

  test "should save valid payload" do
    payload = Payload.new(content: "Valid content", mime_type: "text/plain")
    assert payload.save, "Could not save valid payload"
  end

  test "should set default mime_type if not provided" do
    payload = Payload.create(content: "Content")
    assert_equal "text/plain", payload.mime_type, "Did not set default mime_type"
  end

  test "should set expiry_time on creation" do
    payload = Payload.create(content: "Content")
    assert_not_nil payload.expiry_time, "Did not set expiry_time on creation"
  end

  test "should not save payload with expiry_time exceeding maximum allowed" do
    payload = Payload.new(content: "Content", expiry_time: 31.days.from_now)
    assert payload.save, "Could not save payload with expiry_time exceeding maximum allowed"
    assert_in_delta 30.days.from_now, payload.expiry_time, 1.second, "Did not adjust expiry_time to maximum allowed"
  end
end

================
File: test/test_helper.rb
================
require "simplecov"
require "simplecov-cobertura"

SimpleCov.start "rails" do
  enable_coverage :branch
  formatter SimpleCov::Formatter::CoberturaFormatter
end

ENV["RAILS_ENV"] ||= "test"
require_relative "../config/environment"
require "rails/test_help"

module ActiveSupport
  class TestCase
    # Run tests in parallel with specified workers
    parallelize(workers: :number_of_processors, with: :threads)

    # Setup all fixtures in test/fixtures/*.yml for all tests in alphabetical order.
    fixtures :all

    # Add more helper methods to be used by all tests here...
  end
end
